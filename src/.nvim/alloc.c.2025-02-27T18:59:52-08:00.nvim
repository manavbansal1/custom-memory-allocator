#include "alloc.h"
#include <unistd.h>

static struct header *head = NULL; // Head of the linked list
static void * start_of_heap = NULL;  // for address of initial porogram break
static void * end_of_heap = NULL;  // for address of the current program break in the memory layout

/* finder alogorithms:
   Uses the ptr to the header of the block for success
   Uses NULL for No free memory block as big found
*/
struct header *find_first_fit(struct header *free_list_ptr, int size) {
  // struct header* ret = NULL;
  if (free_list_ptr == NULL) { // List has not been initialized yet
    return NULL;
  }

  struct header *temp = free_list_ptr; // Start of the List
  while (temp != NULL) {
    if (temp->size >= size) {
      return temp; // Great Success
    }
    temp = temp->next; // Move to next one
  }
  // ret = NULL;
  return NULL; // No memory block as big found
}

// Worst Fit

struct header *find_worst_fit(struct header *head, int size) {
  if (head == NULL) {
    // ret = NULL;
    // return -1;
    return NULL;
  }
  struct header *worst =
      NULL; // for keeping track of worst one found till that pt
  struct header *temp = head; // Justr to iterate through the list
  while (temp != NULL) {
    if (temp->size >= size &&
        (worst == NULL ||
         worst->size < temp->size)) // If current one is worst that worst
    {
      worst = temp;
    }
    temp = temp->next;
  }
  // if (worst->size >= size) // The wiorst one has size >= required size
  /*{
    // ret = worst;
    return worst;
  }*/
  // ret = NULL;
  if (worst != NULL) {
    return worst;
  }
  return NULL;
}

// Best fit

struct header *find_best_fit(struct header *head, int size) {
  if (head == NULL) { // Uninitialized Linked list
    // ret = NULL;
    return NULL;
  }

  struct header *best = NULL; // The best one found yet
  struct header *temp = head; // For iterating through the lsit

  while (temp != NULL) {
    if (temp->size >= size) {
      if (best == NULL)
        best = temp;
      else if (best->size > temp->size)
        best = temp;
    }
    temp = temp->next;
  }
  if (best == NULL) {
    // ret = NULL;
    return NULL;
  } else {
    // ret = best;
    return best; // GReat Success!
  }
}

// Function for removing a block from linked list
// void function : Removes the block from free linked list
// does nothing if block not found or the list is empty

void remove_block(struct header *block) {
  if (head == NULL) // Empty Linked Lsit: Do nmothing and return
  {
    return;
  }

  // Case when the head is the block to be removed
  if (head == block) {
    head = head->next; // Just move the head to the next pozs
    return;            // DOne!
  }

  struct header *temp = head;
  while (temp != NULL) {       // Till the end of ythe linked list
    if (temp->next == block) { // If the mnext blcok is thye one to remove
      break;
    }
    temp = temp->next;
  }

  if (temp != NULL) {
    temp->next = block->next;
  }
}

// Funxtion to append a newly freed block into the linked list
// void function: Appends at the front on the list

void append_front(struct header *block) {
  block->next = head; // block->points to the prev head
  head = block;       // Upfate head
  return;
}

/*
 * alloc() allocates memory from the heap. The first argument indicates the
 * size. It returns the pointer to the newly-allocated memory. It returns NULL
 * if there is not enough space.
 */
void *alloc(int size) {
  if (size <= 0) // Negative increment of the heap
    return NULL;

  return NULL;
}

/*
 * dealloc() frees the memory pointed to by the first argument.
 */
void dealloc(void *ptr) {}

/*
 * allocopt() sets the options for the memory allocator.
 *
 * The first argument sets the algorithm. The second argument sets the size
 * limit.
 * Calling allocpt() should should serve as a reset pt.
 */
void allocopt(enum algs algorithm, int limit) {
  
}

/*
 * allocinfo() returns the current statistics.
 */
struct allocinfo allocinfo(void) {
  struct allocinfo info_block = {0};
  return info_block;
}
