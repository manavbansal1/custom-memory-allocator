#define _POSIX_C_SOURCE 200809L
#define _GNU_SOURCE 1 // Took Google's help to find the src of err for sbrk
#include "alloc.h"
#include <unistd.h>

static struct header *head = NULL; // Head of the linked list
static void *start_of_heap = NULL; // for address of initial porogram break
static void *end_of_heap =
    NULL; // for address of the current program break in the memory layout
static uint64_t size_of_heap = 0;
// USed Google's help to find the way to deal with enums and declare variables
static enum algs curr_algorithm = FIRST_FIT; // Defualt
static int system_limit = 0;

/* finder alogorithms:
   Uses the ptr to the header of the block for success
   Uses NULL for No free memory block as big found
*/
struct header *find_first_fit(struct header *free_list_ptr, int size) {
  // struct header* ret = NULL;
  if (free_list_ptr == NULL) {
    // List has not been initialized yet
    return NULL;
  }

  struct header *temp = free_list_ptr; // Start of the List
  while (temp != NULL) {
    if (temp->size >= size) {
      return temp; // Great Success
    }
    temp = temp->next; // Move to next one
  }
  // ret = NULL;
  return NULL; // No memory block as big found
}

// Worst Fit

struct header *find_worst_fit(struct header *head, int size) {
  if (head == NULL) {
    return NULL;
  }
  struct header *worst = NULL; // for keeping track of worst till that pt
  struct header *temp = head;  // Justr to iterate through the list
  while (temp != NULL) {
    if (temp->size >= size && (worst == NULL || worst->size < temp->size)) {
      // If current one is worst that worst
      worst = temp;
    }
    temp = temp->next;
  }
  return worst;
}

// Best fit

struct header *find_best_fit(struct header *head, int size) {
  if (head == NULL) { // Uninitialized Linked list
    return NULL;
  }

  struct header *best = NULL; // The best one found yet
  struct header *temp = head; // For iterating through the lsit

  while (temp != NULL) {
    if (temp->size >= size) {
      if (best == NULL || best->size > temp->size){
      best = temp;
      }
    }
    temp = temp->next;
  }
  return best;
}

// A joint function for all the finding stuff
struct header *find_free_block(int size) {

  switch (curr_algorithm) {
  case FIRST_FIT:
    return find_first_fit(head, size);
  case BEST_FIT:
    return find_best_fit(head, size);
  case WORST_FIT:
    return find_worst_fit(head, size);
  default:
    return find_first_fit(head, size);
  }
}

// Function for removing a block from linked list
// void function : Removes the block from free linked list
// does nothing if block not found or the list is empty

void remove_block(struct header *block) {
  if (head == NULL) { // Empty Linked Lsit: Do nmothing and return
    return;
  }

  // Case when the head is the block to be removed
  if (head == block) {
    head = head->next; // Just move the head to the next pozs
    return;            // DOne!
  }

  struct header *temp = head;
  while (temp != NULL && temp->next != block) { 
    // Till the end of ythe linked list
    temp = temp->next;
  }

  if (temp != NULL) {
    temp->next = block->next;
  }
}


// Funxtion to append a newly freed block into the linked list
// void function: Appends at the front on the list
void append_front(struct header *block) {
  block->next = head; // block->points to the prev head
  head = block;       // Upfate head
}


// Function to initialize the heap if necessary
void init_heap_if_needed() {
  // Initialize the Linked list if not already
  if (head == NULL) {
    start_of_heap = sbrk(0);     // Initial program break
    // end_of_heap = start_of_heap; // Initially 
    // Above end_of_heap no longer needed
    size_of_heap = 0;
  }
}


// A function to extend heap when no free blcok in linked list is found
// returns NULL if it fails due to some reason
struct header *extend_heap(int num_bytes) {
  // int num_of_increments_required = (num_bytes + INCREMENT - 1) / INCREMENT;
  // int num_of_bytes_request = num_of_increments_required * INCREMENT;
  
  // If the requirement exceds the limit set by the user
  if (system_limit > 0 && size_of_heap + INCREMENT > system_limit) {
    return NULL; // Return NULL : Request failed due to the limit
  }

  // Extending the heap using sbrk
  // void *new_block = sbrk(num_of_bytes_request);
  void *new_block = sbrk(INCREMENT);

  if (new_block == (void *)-1) { 
    // If sbrk fails it returns -1
    return NULL;
  }

  struct header *block =
      (struct header *)new_block; // Creating a header for newly alloc memory

  // Although in Class we did size = size + headersize
  block->size = INCREMENT; // - sizeof(struct header);
  block->next = NULL;

  // append_front(block); // Add to the free list

  // Updating the heap end
  // Not needed: end_of_heap = (char *)end_of_heap + INCREMENT;
  // num_of_bytes_request;
 
  size_of_heap += INCREMENT;
  return block; // The free block that is avialable to be allocated
}
// Function to coalsce the two adjacent blocks
void coalesce_blocks() { // Accepts the new incoming block
  if (head == NULL || head->next == NULL) {
    return;
  }

  int coalesced;

  do {
    coalesced = 0; // FLag for coalescing

    struct header *temp = head; // for iterating
    while (temp != NULL) {
      struct header *block = head;
      while (block != NULL) {
        if (temp != block) {
          char *end1 = (char *)temp + temp->size;
          // void * end2 = (void*)block - sizeof(struct header) - block->size;
          if (end1 == (char *)block) { // We have it order block <- temp
            temp->size += block->size; // Make their sizes equal
            remove_block(block);
            coalesced = 1; // Setting coalesced to true
            // temp = head; // start looking again
            break; // break inner loop as block is now invalid
          }
          char *end2 = (char *)block + block->size;
          // void * end2 = (void*)block - sizeof(struct header) - block->size;
          if (end2 == (char *)temp) {  // We have it order block -> temp
            block->size += temp->size; // Make their sizes equal
            remove_block(temp);
            coalesced = 1; // Setting coalesced to true
            // temp = head; // start looking again
            break; // break inner loop as block is now invalid
          }
        }
        block = block->next;

        // if (block == NULL) // No coalescing
        //{
        // temp = temp->next; // Move to next one
        //}
      }
      if (coalesced) {
        break;
      }
      temp = temp->next;
    }
  } while (coalesced);
}
/*
 * alloc() allocates memory from the heap. The first argument indicates the
 * size. It returns the pointer to the newly-allocated memory. It returns NULL
 * if there is not enough space.
 */
void *alloc(int size) {
  if (size == 0){ 
    // Negative increment of the heap
    return (struct header *)sbrk(0);
  }
  if (size < 0){
    // Requesting negativ enumber of bytes
    return NULL;
  }

  init_heap_if_needed();

  uint64_t size_with_header = size + sizeof(struct header);
  // Try to get a free block
  struct header *block = find_free_block(size_with_header);

  if (block == NULL) // Required block not avialable in existing linked list
  {
    // Extend heap and try to allocate space
    block = extend_heap(size_with_header);
    if (block == NULL) {
    // Increasing the limit failed as well
      return NULL;
    }
  } else {
    remove_block(block);
  } // Remove the block if found in the free list

  // Need logic if need to split the block
  if (block->size > size_with_header + sizeof(struct header)) {

    // int size_of_new = block->size - size_with_header;
    struct header *nb = (struct header *)((char *)block + size_with_header);
    nb->next = head;
    nb->size = block->size - size_with_header;
    head = nb;
    block->size = size_with_header;
    // append_front(nb);
  }
  block->next = NULL;
  return (void *)((char *)block + sizeof(struct header));
}

/*
 * dealloc() frees the memory pointed to by the first argument.
 */
void dealloc(void *ptr) {

  if (ptr == NULL) { // NULL passes as argue,emt or heap not initialized
    return;          // Do nothing as the call is not valid
  }

  // Extracting the header from block
  struct header *block = (struct header *)((char *)ptr - sizeof(struct header));
  append_front(block); // Append the newly freed block to the front
  coalesce_blocks();   // Uncomment Later
}

/*
 * allocopt() sets the options for the memory allocator.
 *
 * The first argument sets the algorithm. The second argument sets the size
 * limit.
 * Calling allocpt() should should serve as a reset pt.
 */
void allocopt(enum algs algorithm, int limit) {

  // Reset teh program break
  if (start_of_heap != NULL &&
      size_of_heap > 0) // Some alloc or dealloc has taken place already
  {
    // CAsting into char * because char = 1 byte so we can have the end and
    // first end
    // intptr_t num_bytes =
    //  (char *)end_of_heap - (char *)start_of_heap; // Got the amount of bytes
    // used in the heap
    // if (num_bytes > 0)
    sbrk(-size_of_heap); // Increment the break by -num_bytes (decrement)
  }
  // Reset the variable internally used
  head = NULL;
  start_of_heap = sbrk(0);
  size_of_heap = 0;
  end_of_heap = start_of_heap;

  // Set the algo and limit to the params
  system_limit = limit;
  curr_algorithm = algorithm;
}

/*
 * allocinfo() returns the current statistics.
 */
struct allocinfo allocinfo(void) {
  struct allocinfo info_block = {0};

  /*info_block.free_size = 0;
  info_block.free_chunks = 0;
  info_block.largest_free_chunk_size = 0;
  info_block.smallest_free_chunk_size = UINT64_MAX;
*/
  struct header *temp = head;

  while (temp != NULL) {
    uint64_t actual_size = temp->size - sizeof(struct header);
    info_block.free_chunks++;
    info_block.free_size += actual_size;
    if (actual_size > info_block.largest_free_chunk_size) {
      info_block.largest_free_chunk_size = actual_size;
    }
    if (info_block.smallest_free_chunk_size == 0 ||
        actual_size < info_block.smallest_free_chunk_size) {
      info_block.smallest_free_chunk_size = actual_size;
    }
    temp = temp->next;
  }

  /*if (info_block.free_chunks == 0) { // Edge case when list is empty
    info_block.smallest_free_chunk_size = 0;
    info_block.largest_free_chunk_size = 0;
  }*/

  return info_block;
}
