#define _POSIX_C_SOURCE 200809L
#define _GNU_SOURCE 1 // Took Google's help to find the src of err for sbrk
#include "alloc.h"
#include <unistd.h>

static struct header *head = NULL; // Head of the linked list
static void *start_of_heap = NULL; // for address of initial porogram break
static void *end_of_heap =
    NULL; // for address of the current program break in the memory layout

// USed Google's help to find the way to deal with enums and declare variables
static enum algs curr_algorithm = FIRST_FIT; // Defualt
static int system_limit = 0;
/* finder alogorithms:
   Uses the ptr to the header of the block for success
   Uses NULL for No free memory block as big found
*/
struct header *find_first_fit(struct header *free_list_ptr, int size) {
  // struct header* ret = NULL;
  if (free_list_ptr == NULL) { // List has not been initialized yet
    return NULL;
  }

  struct header *temp = free_list_ptr; // Start of the List
  while (temp != NULL) {
    if (temp->size >= size) {
      return temp; // Great Success
    }
    temp = temp->next; // Move to next one
  }
  // ret = NULL;
  return NULL; // No memory block as big found
}

// Worst Fit

struct header *find_worst_fit(struct header *head, int size) {
  if (head == NULL) {
    // ret = NULL;
    // return -1;
    return NULL;
  }
  struct header *worst =
      NULL; // for keeping track of worst one found till that pt
  struct header *temp = head; // Justr to iterate through the list
  while (temp != NULL) {
    if (temp->size >= size &&
        (worst == NULL ||
         worst->size < temp->size)) // If current one is worst that worst
    {
      worst = temp;
    }
    temp = temp->next;
  }
  // if (worst->size >= size) // The wiorst one has size >= required size
  /*{
    // ret = worst;
    return worst;
  }*/
  // ret = NULL;
  if (worst != NULL) {
    return worst;
  }
  return NULL;
}

// Best fit

struct header *find_best_fit(struct header *head, int size) {
  if (head == NULL) { // Uninitialized Linked list
    // ret = NULL;
    return NULL;
  }

  struct header *best = NULL; // The best one found yet
  struct header *temp = head; // For iterating through the lsit

  while (temp != NULL) {
    if (temp->size >= size) {
      if (best == NULL)
        best = temp;
      else if (best->size > temp->size)
        best = temp;
    }
    temp = temp->next;
  }
  if (best == NULL) {
    // ret = NULL;
    return NULL;
  } else {
    // ret = best;
    return best; // GReat Success!
  }
}
// A joint function for all the finding stuff
struct header *find_free_block(int size) {

  switch (curr_algorithm) {
  case FIRST_FIT:
    return find_first_fit(head, size);
  case BEST_FIT:
    return find_best_fit(head, size);
  case WORST_FIT:
    return find_worst_fit(head, size);
  default:
    return find_first_fit(head, size);
  }
}

// Function for removing a block from linked list
// void function : Removes the block from free linked list
// does nothing if block not found or the list is empty

void remove_block(struct header *block) {
  if (head == NULL) // Empty Linked Lsit: Do nmothing and return
  {
    return;
  }

  // Case when the head is the block to be removed
  if (head == block) {
    head = head->next; // Just move the head to the next pozs
    return;            // DOne!
  }

  struct header *temp = head;
  while (temp != NULL) {       // Till the end of ythe linked list
    if (temp->next == block) { // If the mnext blcok is thye one to remove
      break;
    }
    temp = temp->next;
  }

  if (temp != NULL) {
    temp->next = block->next;
  }
}

// Funxtion to append a newly freed block into the linked list
// void function: Appends at the front on the list

void append_front(struct header *block) {
  block->next = head; // block->points to the prev head
  head = block;       // Upfate head
  return;
}
// Function to initialize the heap if necessary
void init_heap_if_needed() {
  // Initialize the Linked list if not already
  if (head == NULL) {
    start_of_heap = sbrk(0);     // Initial program break
    end_of_heap = start_of_heap; // Initially
  }
}

// A function to extend heap when no free blcok in linked list is found
// returns NULL if it fails due to some reason

struct header *extend_heap(int num_bytes) {
  int num_of_increments_required = (num_bytes + INCREMENT - 1) / INCREMENT;
  int num_of_bytes_request = num_of_increments_required * INCREMENT;

  // If the requirement exceds the limit set by the user
  if (system_limit > 0 &&
      (uint64_t)((char *)end_of_heap - (char *)start_of_heap +
                 num_of_bytes_request) > (uint64_t)system_limit) {
    return NULL; // Return NULL : Request failed due to the limit
  }

  // Extending the heap using sbrk

  void * new_block = sbrk(num_of_bytes_request);
  if (new_block == (void*)-1){  // If sbrk fails it returns -1
    return NULL;
  }
  
  struct header* block = (struct header*)end_of_heap;  // Creating a header for newly alloc memory
  
  // Although in Class we did size = size + headersize 
  // I am using just the size for simplicity purpose
  block->size = num_of_bytes_request - sizeof(struct header);
  block->next = NULL;

  append_front(block);  // Add to the free list

  // Updating the heap end
  end_of_heap = (char*)end_of_heap + num_of_bytes_request;

  return block;  // The free block that is avialable to be allocated
}


/*
 * alloc() allocates memory from the heap. The first argument indicates the
 * size. It returns the pointer to the newly-allocated memory. It returns NULL
 * if there is not enough space.
 */
void *alloc(int size) {
  if (size <= 0) // Negative increment of the heap
    return NULL;

  init_heap_if_needed();

  // Try to get a free block
  struct header *block = find_free_block(size);

  if (block == NULL) // Required block not avialable in existing linked list
  {
    // Extend heap and try to allocate space
    block = extend_heap(size + sizeof(struct header));
    if (block == NULL) // Increasing the limit failed as well
      return NULL;
  }

  remove_block(block); // Remove the block if found in the free list

  // Need logic if need to split the block

  return (void *)((char *)block + sizeof(struct header));
}

/*
 * dealloc() frees the memory pointed to by the first argument.
 */
void dealloc(void *ptr) {}

/*
 * allocopt() sets the options for the memory allocator.
 *
 * The first argument sets the algorithm. The second argument sets the size
 * limit.
 * Calling allocpt() should should serve as a reset pt.
 */
void allocopt(enum algs algorithm, int limit) {

  // Reset teh program break
  if (start_of_heap != NULL &&
      end_of_heap != NULL) // Some alloc or dealloc has taken place already
  {
    // CAsting into char * because char = 1 byte so we can have the end and
    // first end
    intptr_t num_bytes =
        (char *)end_of_heap - (char *)start_of_heap; // Got the amount of bytes
                                                     // used in the heap
    if (num_bytes > 0)
      sbrk(-num_bytes); // Increment the break by -num_bytes (decrement)
  }
  // Reset the variable internally used
  head = NULL;
  end_of_heap = NULL;
  start_of_heap = NULL;

  // Set the algo and limit to the params
  system_limit = limit;
  curr_algorithm = algorithm;
}

/*
 * allocinfo() returns the current statistics.
 */
struct allocinfo allocinfo(void) {
  struct allocinfo info_block = {0};
  return info_block;
}
